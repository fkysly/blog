### 引子

C 语言中，经常会使用结构体去定义一个节点类型。

譬如：

``` c
struct node {
  int value;
};
```

如果说现在需要实现，一个节点连接一个节点，也就是形成一个链表结构，就会写成如下形式：

``` c
struct node {
  int value;
  struct node *next;
};
```

在这里，编译器执行到第3行语句的时候，结构体 node 还没有定义完成，可是我们已经用其声明了 next 这个指针，这就很奇怪。实际上，这里牵扯到 C 语言的不完全类型（ incomplete type ）的概念。

------

### 理解

C 语言中，共有三种不完全类型：

- 没有完全定义的数组（ array ）类型
- 没有完全定义的结构体（ struct ）类型
- 没有完全定义的联合（ union ）类型

所谓不完全类型，就是编译器解析到定义语句的时候，并不知道当前类型的具体定义。也就是说，上个例子中执行到 *next 那条语句的时候，编译器还不知道 struct node 的类型具体有啥。在这个时候，编译器允许开发者使用指针类型，指向当前的不完全类型，也就是上文的 next 指针可以指向 struct node 类型。

不完全类型有几种使用形式：

- 指向不完全类型的指针
- 返回不完全类型的函数
- 不完全函数参数类型
- 不完全类型的 typedef 名称

------

### 应用

由于不完全类型的形式所限，开发者无法去访问不完全类型的具体定义，相当于进行了一层安全隔离。这有点像面向对象语言中的权限控制。

譬如，现在有一个类库开发者 A ，一个应用开发者 B 。

A 希望提供一个排序功能给 B 开发者用，但是需要 B 开发者提供自己的名字，获取到排序的 key 结构，来启动排序功能（当然这里为了讲解，需求不是那么符合逻辑）。而 A 不希望 B 能够操作这个 key 结构，但是又希望自己能操作（所以不能把结构体里面的值都搞成常量），这时候就需要借用不完全类型来解决问题。

A 首先在私有头文件中定义了仅供自己玩耍的结构体 inner_key 。

``` c
struct INNER_key {...}; 
```

A 接着在公共头文件中设计了两个接口函数，第一个函数会返回给 B 一个不完全类型 SORT_key 的指针 *sort_key 。不完全类型的 typedef 也暴露在这个公共头文件中。

``` c
typedef struct INNER_key SORT_key;
SORT_key *sort_key get_sort_key(char *name);
```

第二个函数会传入取到的指针 *sort_key，调用底层的排序功能。

``` c
void sort_array(SORT_key *sort_key, int *arr);
```

在这里，由于不完全类型的限制，开发者 B 只能获取不完全类型的指针，但是无法通过该指针访问、修改不完全类型的内容，这将大大增加接口的安全型，起到了隔离效果。